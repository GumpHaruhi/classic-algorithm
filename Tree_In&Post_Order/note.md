> order.cpp

给出一个树的中序序列和后序序列，返回树的前序序列。

按照两个序列将树重构，再把树解码为前序序列
对于每一个节点，后序序列 postorder 的最后一位即为当前节点的值，记为value
在中序序列中找到value，value左边的部分属于当前节点的左子树，右边的部分属于当前节点的右子树
以value为轴切割中序序列为两部分，并把后序序列相应的切割成与这两部分等长的两段
递归，即可构造树

已知中序序列，前、后序列知道一个即可推出另一个。

> SDtree.cpp

是对上一个任务中提到的前中后序列的应用

这里实现两个函数，Sesiralize 函数把给定的树解码成字符串，Desiralize 函数按字符串重构树

要求无论怎样，重构之后的树必须和之前结构一样

为了达成目的，S函数的解码工作要把树解码为中序序列和后序序列，并把两个序列作为一个字符串返回

每个节点值后面有"#"作标记，中序序列和后序序列中间用"/"隔开

函数 midstr 负责把树解码为中序序列，aftstr 解码为后序序列

对于每一个节点，后序序列 postorder 的最后一位即为当前节点的值，记为 value

在中序序列中找到 value，value 左边的部分属于当前节点的左子树，右边的部分属于当前节点的右子树

以 value 为轴切割中序序列为两部分，并把后序序列相应的切割成与这两部分等长的两段

```
example:
for this loop:
    inorder: 6 8 15 16 21 18 24 45 32 41 48 49
    postorder: 6 15 8 18 21 16 41 32 48 49 45 24
    root: 24
for next loop:
    left:
        inorder: 6 8 15 16 21 18
        postorder: 6 15 8 18 21 16
    right:
        inorder: 45 32 41 48 49
        postorder: 41 32 48 49 45
            
```



递归即可构造树