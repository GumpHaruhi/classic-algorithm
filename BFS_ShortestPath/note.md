> non_weight.cpp

给定 n 个节点和 m 条边，组成一个无权无环图，给定两个节点 u, v, 找出 u to v 的最短路径，返回路径长度。没有则返回 -1
这显然是广度优先搜索。使用并查集和图的知识，这里使用并查集仅仅因为容易维护，且判断 u v 是否有通路上方便
核心函数 findPath，findPath(beginer, endline, road) 返回从 beginer to endline 的最短路径
其中 vector<int> 型的 road 储存了已走过的节点，防止算法走回头路陷入死循环（图中可以有环的存在）
如样例一，数据结构应该是

```
          7     2
​          5     6  2  6
​       3  1  3  3  7  7
graph: 1->3->5->7->6->2  4

input:
7 7 6 5
1 3
3 5
3 7
6 7
7 2
2 6
4 4
output:
3

input:
8 9 4 5
1 3
3 5
1 5
3 7
7 2
7 6
2 6
8 8
2 4
output:
4
```



> weight.cpp

上面的 non_weight 代码写的比较早，实现手法很幼稚，代码也低能，但对于并查集的使用仍不失为一种思路，故留下它吧
在 weight.cpp 中，题目条件变了：
同样是查找最短路径，给定无权图的边和边的权重（即有了边长），查找点 u to v 的最短路径。

维护了两种数据结构：Node & Edge，故名思意。核心算法是BFS，加入使用并查集仅为方便

~~不过这次的并查集使用更加优雅~~

上一题使用一个 vector road 来储存走过的路，这实在是太愚蠢了

本题在 Node 数据中加入了 black 属性，未走过的点是白的 (false)，走过的点是黑的 (true)

比如搜索到当前的点 N，与它相连的点有 a b c , 将N染黑，然后对 a b c 递归的调用 minPath 函数。
在全部调用完以后，需要将 N 染白，保证 N 的上一代的子代（即与N同代的那些点）正确搜索。

```
input:
5 4 2 4
0 1 34
1 2 57
2 3 47
3 4 67
output:
114
```

